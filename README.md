# Цель:

**Целью** выполнения данной курсовой работы является закрепление и углубление
теоретических знаний в области современных операционных систем, приобретение
практических навыков разработки клиент-серверных приложений, использующих

системные механизмы межпроцессного взаимодействия.

# **Задачи**:

1. Изучить методы разработки клиент-серверных приложений.
2. Изучить механизмы обмена данными в Windows NT и GNU/Linux и особенности их
применения на практике.
3. Изучить средства синхронизации процессов в Windows NT и GNU/Linux и особенности
их применения на практике.
4. Изучить функции WinAPI и возможности Linux для получения системной информации,
информации о процессах и потоках, состоянии памяти.
5. Разработать серверные приложения и приложение-клиент, обменивающиеся данными
через заданный интерфейс.
6. Оформить результаты выполнения курсовой работы в виде пояснительной записки в
соответствии с предъявляемыми требованиями.

# Задание:

1. Разработать многозадачное приложение, выполняющее получение, сбор и вывод системной информации в соответствии с вариантом задания (таблица 1). Номер варианта задания на курсовую работу совпадает с номером, под которым записана фамилия студента в журнале группы. Мой вариант 16.

![Untitled](%D0%9A%D1%83%D1%80%D1%81%D0%BE%D0%B2%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%BF%D0%BE%20%D0%9E%D0%A1%20b1191ee1b71f463d8947b66f0304e2b6/Untitled%201.png)

![Untitled](%D0%9A%D1%83%D1%80%D1%81%D0%BE%D0%B2%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%BF%D0%BE%20%D0%9E%D0%A1%20b1191ee1b71f463d8947b66f0304e2b6/Untitled%202.png)

## **Общие указания к выполнению работы**

Многозадачное приложение реализуется на основе технологии «клиент-сервер»
средствами интегрированной среды разработки Microsoft Visual Studio/Visual C++ или
редактора Visual Studio Code, по согласованию с преподавателем возможно использование
других компиляторов и языков программирования. Процессы 1 и 2 выступают как серверы
приложений, третий процесс является их клиентом. Обмен данными между клиентами и
серверами осуществляется при помощи сокетов.

И клиентские, и серверные процессы оформляются как отдельные приложения,
запускаются и завершают работу независимо друг от друга. Серверы должны быть
многопоточными, то есть допускать одновременное подключение нескольких клиентов.
Серверные процессы по запросу получают системную информацию в соответствии с
вариантом задания и передают ее клиенту с указанием текущего времени. На стороне
клиента необходимо реализовать интерфейс, позволяющий пользователю подключиться
по выбору к первому или второму серверу, а также возможность раздельного получения и
отображения данных по каждому из пунктов индивидуального задания.

Необходимо предусмотреть проверку на повторный запуск серверов, т.е. исключить
ситуацию, когда запускается более чем один экземпляр каждого сервера. В течение всего
времени подключения клиента к серверу информация в клиентской части должна
обновляться либо автоматически, либо по команде от пользователя.

## **Дополнительные задания**

1. Запуск клиентов в контейнерах.
2. Наличие версии сервера или клиента под ОС Linux (т.е., если клиент и сервер работают под разными ОС).
3. Демонстрация работы разработанных приложений на двух устройствах (физических или в виртуальных машинах).

# Содержание:

1. Цели 
2. Задачи
3. Задание
4. Дополнительные задания
5. Содержание 
6. Введение 

# Введение:

Современные информационные технологии вносят значительные изменения в архитектуру и организацию вычислительных систем. В этом контексте сетевые приложения, способные обмениваться данными между удаленными узлами, становятся неотъемлемой частью современного программного обеспечения. Данная работа посвящена разработке и многопоточному обслуживанию сетевых серверов, способных предоставлять информацию о системных ресурсах двух удаленных узлов.

Целью данной работы является создание и настройка пары серверов, каждый из которых предоставляет уникальную информацию о своем хосте, такую как использование памяти и время работы в пользовательском режиме. Разработанные серверы будут обеспечивать многопоточное обслуживание клиентских запросов, что позволит одновременно подключаться нескольким клиентам.

Работа включает в себя создание двух серверов, выполненных в виде отдельных приложений, а также клиентского приложения для тестирования и взаимодействия с серверами. Сетевое взаимодействие будет реализовано с использованием протокола TCP/IP. Также будут рассмотрены вопросы обработки ошибок, многопоточности и безопасности при работе с сетевыми приложениями.

В процессе разработки будет уделено внимание не только функциональным аспектам системы, но и ее надежности, устойчивости к ошибкам и возможности многопоточного обслуживания клиентов.

# Основная часть:

## **Постановка задачи:**

Целью данной работы является разработка и многопоточное обслуживание сетевых серверов, предоставляющих информацию о системных ресурсах двух удаленных узлов. Задачи включают в себя создание двух серверов, способных обрабатывать множество клиентских запросов, и клиентского приложения для тестирования и взаимодействия с серверами.

## **Теоретические основы:**

"Клиент-сервер" – это модель взаимодействия в компьютерных сетях, где один компьютер (сервер) предоставляет ресурсы, а другие (клиенты) используют эти ресурсы. Преимущества включают удобство, масштабируемость и возможность централизованного управления. Недостатки включают потенциальные проблемы с безопасностью и зависимость от надежности сервера.

## **Алгоритм работы приложения:**

1. **Сервер 1:** Принимает запросы от клиентов, предоставляет информацию о текущем сеансе и часовом поясе.
2. **Сервер 2:** Предоставляет информацию о свободной памяти и времени работы серверного процесса в пользовательском режиме.
3. **Клиент:** Подключается к серверам, отправляет запросы, получает и отображает информацию.

## **Структура программы:**

- **`server1.cpp`**: Реализация сервера 1.
- **`server2.cpp`**: Реализация сервера 2.
- **`client.cpp`**: Реализация клиентского приложения.

**Результаты:**
Открываем три терминала и там запускаем два сервера и клиент

![Untitled](%D0%9A%D1%83%D1%80%D1%81%D0%BE%D0%B2%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%BF%D0%BE%20%D0%9E%D0%A1%20b1191ee1b71f463d8947b66f0304e2b6/Untitled%203.png)

Подключение успешно выполнено. Запрашиваем информацию у первого сервера 

![Untitled](%D0%9A%D1%83%D1%80%D1%81%D0%BE%D0%B2%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%BF%D0%BE%20%D0%9E%D0%A1%20b1191ee1b71f463d8947b66f0304e2b6/Untitled%204.png)

Аналогично запрашиваем информацию у второго сервера 

![Untitled](%D0%9A%D1%83%D1%80%D1%81%D0%BE%D0%B2%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%BF%D0%BE%20%D0%9E%D0%A1%20b1191ee1b71f463d8947b66f0304e2b6/Untitled%205.png)

Пробуем создать новый сервер

![Untitled](%D0%9A%D1%83%D1%80%D1%81%D0%BE%D0%B2%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%BF%D0%BE%20%D0%9E%D0%A1%20b1191ee1b71f463d8947b66f0304e2b6/Untitled%206.png)

Как видим это невозможно

Каждое обслуживание клиента на сервере осуществляется каждый в своем потоке

`std::thread(handleClient, clientSocket).detach();`

При принятии запроса от клиента накладывается мьютекс для защиты доступа к ресурсам

```cpp
{
        std::lock_guard<std::mutex> lock(server1Mutex); // Защита доступа к ресурсам
        // Отправка ответа клиенту
        send(clientSocket, response.c_str(), response.length(), 0);
    }
```


Для выполнения дополнительного задания портируем клиент на OS Windows

Для начала изменим заголовочные файлы

```cpp
#include <iostream>
#include <cstring>
#include <winsock2.h>
```

Я добавил инициализацию и завершение использования библиотеки Winsock в функции **`main`** и **`fetchDataFromServer`**. Также использованы соответствующие функции для работы с сокетами под Windows, такие как **`closesocket`** вместо **`close`** и **`WSACleanup`** для завершения работы с Winsock.

И настраиваем кодировку для PS `SetConsoleOutputCP(CP_UTF8);`

```cpp
void fetchDataFromServer(const char* serverIP, int serverPort) {
    // Инициализация библиотеки Winsock
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        std::cerr << "Ошибка при инициализации Winsock\n";
        return;
    }

    // Создание сокета
    SOCKET clientSocket = socket(AF_INET, SOCK_STREAM, 0);
    if (clientSocket == INVALID_SOCKET) {
        std::cerr << "Ошибка при создании сокета\n";
        WSACleanup();
        return;
    }

    // Установка адреса сервера
    sockaddr_in serverAddress{};
    serverAddress.sin_family = AF_INET;
    serverAddress.sin_port = htons(serverPort);

    // Используйте inet_pton для преобразования строки в IP-адрес
    serverAddress.sin_addr.s_addr = inet_addr(serverIP);
    if (serverAddress.sin_addr.s_addr == INADDR_NONE) {
        std::cerr << "Ошибка при преобразовании IP-адреса\n";
        closesocket(clientSocket);
        WSACleanup();
        return;
    }

    // Подключение к серверу
    if (connect(clientSocket, (struct sockaddr*)&serverAddress, sizeof(serverAddress)) == SOCKET_ERROR) {
        std::cerr << "Ошибка при подключении к серверу\n";
        closesocket(clientSocket);
        WSACleanup();
        return;
    }

    // Получение данных от сервера
    char buffer[1024];
    memset(buffer, 0, sizeof(buffer));
    int bytesRead = recv(clientSocket, buffer, sizeof(buffer), 0);
    if (bytesRead == SOCKET_ERROR) {
        std::cerr << "Ошибка при чтении данных от сервера\n";
    } else {
        std::cout << "Данные от сервера:\n" << buffer << std::endl;
    }

    // Закрытие сокета при завершении работы
    closesocket(clientSocket);
    WSACleanup();
}
```

### Дополнительное задание 2

Для демонстрации работы на разных физических устройствах необходимо прописать не localhost, а адрес нашего компьютера в локальной сети. И открыть подключение в Брандмауре!!

Было 

```cpp
int serverPort;
        const char* serverIP;

        switch (choice) {
            case '1':
                serverPort = 8081;
                serverIP = "127.0.0.1";
                break;
            case '2':
                serverPort = 8082;
                serverIP = "127.0.0.1";
                break;
            default:
                std::cout << "Некорректный ввод\n";
                continue;
        }
```

Стало

```cpp
int serverPort;
        const char* serverIP;

        switch (choice) {
            case '1':
                serverPort = 8081;
                serverIP = "192.168.0.61";
                break;
            case '2':
                serverPort = 8082;
                serverIP = "192.168.0.61";
                break;
            default:
                std::cout << "Некорректный ввод\n";
                continue;
        }
```

Подключаемся с клиента в Windows

![Untitled](%D0%9A%D1%83%D1%80%D1%81%D0%BE%D0%B2%D0%B0%D1%8F%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%20%D0%BF%D0%BE%20%D0%9E%D0%A1%20b1191ee1b71f463d8947b66f0304e2b6/Untitled%207.png)

### Дополнительное задание 3

Создаем Dockerfile

```docker
# Используйте официальный образ Windows Server Core
FROM mcr.microsoft.com/windows/servercore:ltsc2019

# Копируйте исходный код в контейнер
WORKDIR /app
COPY client.cpp .

# Установите компилятор и библиотеку Winsock
RUN curl -o VC_redist.x64.exe https://aka.ms/vs/16/release/VC_redist.x64.exe && \
    VC_redist.x64.exe /quiet /install && \
    del VC_redist.x64.exe

# Компиляция исходного кода
RUN cl /EHsc client.cpp /link /out:client.exe

# Запуск приложения при запуске контейнера
CMD ["client.exe"]
```

Собираем образ `docker build -t my_client_app .`

Запускаем `docker run my_client_app`
